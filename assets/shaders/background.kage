package main

var CameraY float
var ScreenSize vec2

func hash(p vec2) float {
	return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)
}

func sdCircle(p, c vec2) float {
	i := floor(p)
    f := fract(p)
	r := 0.5*hash(i+c)
	
	return length(f-c)-r
}

func smin(d0, d1 float) float {
	const k = 0.01

	h := clamp(0.5 + 0.5*(d1 - d0)/k, 0.0, 1.0)
	return mix(d1, d0, h) - k * h * (1.0-h)
}

func sd(p vec2) float {
	return smin(
		smin(sdCircle(p, vec2(0., 0.)), sdCircle(p, vec2(0., 1.))),
		smin(sdCircle(p, vec2(1., 0.)), sdCircle(p, vec2(1., 1.))),
	)
}

func colorize(t, y float) vec3 {
	const pi = 3.141592653589

	/*midclr := mix(
		vec3(0.27, 0.84, 0.17),
		vec3(0.5, 0., 0.5),
		sin(y*pi/2.),
	)*/
	// v := (sin((y*2.-0.5)*pi)+1)/2.
	midclr := (sin((y/8.*vec3(0.5, 0., 0.8)-0.5)*pi)+1.)/2.
	
	centerclr := mix(
		vec3(1., 0.8, 0.),
		vec3(0.5, 0.8, 1.),
		sin(y*pi),
	)
	centerclr = vec3(1., 0.8, 0.)

	t = smoothstep(0., 1., t)
	clr := mix(
		midclr,
		centerclr,
		t,
	)
	clr = mix(
		vec3(0.05),
		clr,
		t,
	)
	
	return clr
}

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
	p := texCoord * 2. - 1.
	p.y -= ((CameraY/ScreenSize.y)*2.-1.)
	p.y = p.y / 16. * 9.

	t := 10.+abs(position.y-CameraY)/1000.
	d0 := abs(sd(vec2(p.x*t, p.y)))
	d1 := abs(sd(vec2(p.x, p.y*t)))
	
	d := max(d0, d1) // banger

	clr := colorize(d, p.y)
	// clr = clr*clr*(3.-2.*clr)

	return vec4(clr, 1.)
}